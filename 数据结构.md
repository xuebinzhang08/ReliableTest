```plain
数组长度：nums.size()
```
# 定义Hashtable

```c++
#include <unordered_map>
unordered_map<int, int> stored;
//添加元素
stored[nums[i]] = i; //key val
//查找元素
auto it = stored.find(target - nums[i]); //find 在key中找; auto是自动推断类型
//返回值是iterator 可以用
if(stored.find(target - nums[i])!=sorted.end()){
  return sorted[target - nums[i]];
}//取val
```
## 例题

* [leetcode 340 最多带有K个不同字符的最长子字符串](https://blog.csdn.net/zy450271923/article/details/105429677) 滑动窗口

用hashmap + 滑动窗口 不能保证O(n)

```c++
int lengthOfLongestSubstringKDistinct(string s, int k) {
        int s_len = s.size();
        if(k*s_len==0) return 0;
        int left=0, right=0;
        int max_len = 1;
        unordered_map<char, int> dict;
        while(right<s_len){
            dict[s[right]] = right;
            right++;
            if(dict.size()>k){
                int lowest = INT_MAX;
                for(pair<char, int> element:dict){
                    lowest = min(lowest, element.second);
                }
                left = lowest+1;        
                dict.erase(s[lowest]);
            }
            max_len = max(max_len, right-left);
        }
        return max_len;
    }
```

# 定义一维数组

## 用vector

```c++
vector<bool> dp(subSetSum + 1, false);
```
### 查找数组中最大值及坐标

```c++
vector<int> a = { 2,4,6,7,1,0,8,9,6,3,2 };
auto maxPosition = max_element(a.begin(), a.end());
cout << *maxPosition << " at the postion of " << maxPosition - a.begin() <<endl;
cout << a[maxPosition - a.begin()] << " at the postion of " << distance(a.begin(), maxPosition) << endl;
```
如果有多个，迭代器返回第一个。
### 合并两个vector

a+b，把b接在a后面

```c++
vector<int> a = {2,4,6,7};
vector<int> b = {3,5,9,10};
a.insert(a.end(), b.begin(), b.end());
```
### 插入元素

```c++
//后面添加
a.push_back(element);
//插到头部
a.insert(a.begin(),element);
//插到指定位置
a.insert(a.begin()+5,30);a
cout<<a[5]<<endl;
//插入多个
a.insert(pos,n,elem);   在pos位置插入n个elem数据，无返回值 pos:a.begin()+5
```


## 普通方式

```c++
int[] dp = new int[amount + 1];
//初始值为0
```
# 定义二维数组

## 普通

```c++
#include <string.h>
bool dp[length+1][halfsum+1];
memset(dp, 0, (length+1)*(halfsum+1)*sizeof(bool)); //赋值
```
### memset用法

只有char才可以赋任意值

```c++
char data[10];
memset(data, 1, sizeof(data));    // right
memset(data, 0, sizeof(data));    // right

int data[10];
memset(data, 0, sizeof(data));    // right
memset(data, -1, sizeof(data));    // right
memset(data, 1, sizeof(data));    // wrong, data[x] would be 0x0101 instead of 1
```

## 用vector

```c++
vector<vector<bool> > dp(m,vector<bool>(n,false)); //m行n列
```
#  string 字符串

定义字符串

```c++
string s = "";
s = s + 'a';
```
截取字符串
```c++
string sub = s.substr(i,j); //i是启示位置，j是长度
```
字符串长度
```c++
int len = s.size();
```
删除字符
```c++
s.earse(pos,n)//pos是起始位置，n是删除长度 缺省全删
```
比较两个字符串相等 a、b
```c++
a == b
//或者
a.compare(b); //相等返回0,a小返回-1，a大返回1
```
末尾追加元素
```c++
a.push_back('c');
```
# char* 字符串

```c++
//比较两个字符串 s1，s2
strcmp(const char* s1,const char* s2); //相等0，s1<s2负数，s1>s2 正数
//不能用 == 判断相等
```
# stack

* empty() 堆栈为空则返回真
* pop() 移除栈顶元素
* push() 在栈顶增加元素
* size() 返回栈中元素数目
* top() 返回栈顶元素
# queue

* front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。
* back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。
* push(const T& obj)：在 queue 的尾部添加一个元素的副本。
* pop()：删除 queue 中的第一个元素。
* size()：返回 queue 中元素的个数。
* empty()：如果 queue 中没有元素的话，返回 true。
# deque

定义的实现代码如下：

```c++
deque<int> a; // 定义一个int类型的双端队列a
deque<int> a(10); // 定义一个int类型的双端队列a，并设置初始大小为10
deque<int> a(10, 1); // 定义一个int类型的双端队列a，并设置初始大小为10且初始值都为1
deque<int> b(a); // 定义并用双端队列a初始化双端队列b
deque<int> b(a.begin(), a.begin()+3); // 将双端队列a中从第0个到第2个(共3个)作为双端队列b的初始值
```

除此之外，还可以直接使用数组来初始化向量：

```c++
int n[] = { 1, 2, 3, 4, 5 };
// 将数组n的前5个元素作为双端队列a的初值
// 说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，
// 这个主要是为了和deque.end()指针统一。
deque<int> a(n, n + 5); 
deque<int> a(&n[1], &n[4]); // 将n[1]、n[2]、n[3]作为双端队列a的初值
```
 
* 头部添加元素：`deq.push_front(const T& x);`
* 末尾添加元素：`deq.push_back(const T& x);`
* 任意位置插入一个元素：`deq.insert(iterator it, const T& x);`
* 任意位置插入 n 个相同元素：`deq.insert(iterator it, int n, const T& x);`
* 插入另一个向量的 [forst,last] 间的数据：`deq.insert(iterator it, iterator first, iterator last);`
*  容器大小：`deq.size();`
* 容器最大容量：`deq.max_size();`
* 更改容器大小：`deq.resize();`
* 容器判空：`deq.empty();`
* 减少容器大小到满足元素所占存储空间的大小：`deq.shrink_to_fit();`
* 头部删除元素：`deq.pop_front();`
* 末尾删除元素：`deq.pop_back();`
* 任意位置删除一个元素：`deq.erase(iterator it);`
* 删除 [first,last] 之间的元素：`deq.erase(iterator first, iterator last);`
* 清空所有元素：`deq.clear();`
* 下标访问：`deq[1];` // 并不会检查是否越界
* at 方法访问：`deq.at(1);` // 以上两者的区别就是 at 会检查是否越界，是则抛出 out of range 异常
* 访问第一个元素：`deq.front();`
* 访问最后一个元素：`deq.back();`
*  开始迭代器指针：`deq.begin();`
* 末尾迭代器指针：`deq.end();` // 指向最后一个元素的下一个位置
## 元素排序

```c++
#include <algorithm>
sort(deq.begin(), deq.end()); // 采用的是从小到大的排序

// 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:
// 自定义从大到小的比较器，用来改变排序方式
bool Comp(const int& a, const int& b) {
    return a > b;
}
sort(deq.begin(), deq.end(), Comp);
